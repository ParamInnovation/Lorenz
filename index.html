<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<!-- keep the line below for OpenProcessing compatibility -->

	<script src="./jquery/jquery.min.js" type="text/javascript"></script>
	<script src="./round-slider/src/roundslider.js"></script>

	<link rel="stylesheet" type="text/css" href="./round-slider/src/roundslider.css">
	<script src="./P5/p5.js"></script>
	<!-- <script src="./P5/p5.sound.min.js"></script> -->
	<link rel="stylesheet" href="style.css">
	<link href='./dm_sans/dm_sans.css' rel='stylesheet'>
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/swiper@9/swiper-bundle.min.css" />

	<script src="https://cdn.jsdelivr.net/npm/swiper@9/swiper-bundle.min.js"></script>

</head>

<body>

	<div id="#text-container"></div>
	<div class="i-button">
		<div id="curious">Curious to know what it is?</div>
		<div onclick="displayContent()" class="btn"><button id="displayContentlargescreen">i</button></div>
	</div>
	<div class="slider1Container">
		<div class="sliderContainer">
			<div id="slider1">
				<h1>alpha</h1>
			</div>
			
			<div id="slider3">
				<h1>beta</h1>
			</div>
			<div id="slider2">
				<h1>gamma</h1>
				
			</div>
			<div class="moreInfoalphaBeta">
				<div class="moreInfoalphaBetaCircle">
					<div class="contentAlpha">An alpha ,beta values influences the behaviour of a system, like a dial
						controlling the balance between predictable patterns and randomness. By changing these
						alpha,beta value, one can study how the system's behavior changes under different settings.
					</div>
					<button id="skip">Skip</button>
					<div></div>
				</div>
			</div>

		</div>
		<div class="picker">
			<div class="colorPicker">

				<input type="range" id="colorPicker" min="0" max="100" step="1" value="0">
				<div id="colorPreview"></div>

			</div>
		</div>


	</div>
	<div id="outerContainer">
		<div id="container">
			<div id="item" onclick="displayvlueContainer()">
				<i class="fa fa-gear" id="icon" style="font-size:36px;color:#3ABECB"></i>
				<div id="x">X</div>
			</div>
		</div>
	</div>

	<div class="valueContainer1">
		<div class="valueContainer">
			<div class="sliderBlock1">
				<div class="sblock1" id="uniqueslider"></div>
				<div class="sblock1" id="uniqueslider1"></div>
				<div class="sblock1" id="uniqueslider2"></div>
				<div class="sblock1" id="uniqueslider3"></div>
				<div class="sblock1 ">
					<div class="constantValues " id="alphaa">
						<div class="constantcircle">
							<div class="constantcircle1">α</div>
						</div>
						<div id="alpha"></div>
					</div>
					<div class="constantValues" id="betaa">
						<div class="constantcircle">
							<div class="constantcircle1"> β</div>
						</div>
						<div id="beta"></div>
					</div>
					<div class="constantValues" id="gammaa">
						<div class="constantcircle">
							<div class="constantcircle1"> γ</div>
						</div>
						<div id="gamma"></div>
					</div>
				</div>
			</div>
			<div class="sliderBlock2"></div>
			<div class="picker1">
				<div class="colorPicker1">

					<input type="range" id="colorPicker1" min="0" max="100" step="1" value="0">
					<div id="colorPreview1"></div>

				</div>
			</div>
		</div>

		<div>

		</div>

	</div>
	<!-- <div class="i-button" onclick="displayContent()"><button>i</button></div> -->
	<div id="content">
		<div id="innerContent">

			<div class="displayN displayns">
				<!-- <div class="displaynoneformobile">Attractors are patterns or behaviours that systems naturally settle
					into over time. They can be
					thought of as a sort of "magnetic pull" that draws a system toward a specific state or set of
					states. In everyday life, you might see attractors in the way a pendulum swings to a stop, or how
					people form habits and routines.</div>
				<div class="img displaynoneformobile">
					<img src="image.png" alt="img" id="img">
				</div>
				<div class="displaynoneformobile"><Button onclick="displayN()">Exit</Button></div> -->
				<div class="carousel">
					<div class="carousel-inner">
						<input class="carousel-open" type="radio" id="carousel-1" name="carousel" aria-hidden="true"
							hidden="" checked="checked">
						<div class="carousel-item">
							<h1>Astrophysics</h1>
							<div class="IMAGE"><img src="nasa-rTZW4f02zY8-unsplash.jpg"></div>
							<div>
								<P>Galaxies and Cosmic structures show factral patterns,used to model
									the universe's large scale structure</P>
							</div>
							<div class="displaynoneforlargerscreen" id="factral">
								Fractal art is a form of digital art that utilizes mathematical algorithms to create
								self-similar
								patterns and structures.
							</div>
						</div>
						<input class="carousel-open" type="radio" id="carousel-2" name="carousel" aria-hidden="true"
							hidden="">
						<div class="carousel-item">
							<h1>Ocean Current</h1>
							<div class="IMAGE"><img src="pexels-pixabay-462162.jpg"></div>
							<div>
								<p>The Ocean current analysis predicts the complex oceanic
									movement,imapacting climatic and marine life</p>
							</div>
							<div class="displaynoneforlargerscreen" id="factral">
								Fractal art is a form of digital art that utilizes mathematical algorithms to create
								self-similar
								patterns and structures.
							</div>
						</div>
						<input class="carousel-open" type="radio" id="carousel-3" name="carousel" aria-hidden="true"
							hidden="">
						<div class="carousel-item">
							<h1>Medical</h1>
							<div class="IMAGE"><img src="pexels-vidal-balielo-jr-1250655.jpg"></div>
							<div>
								<p>The Ocean current analysis predicts the complex oceanic
									movement,imapacting climatic and marine life</p>
							</div>
							<div class="displaynoneforlargerscreen" id="factral">
								Fractal art is a form of digital art that utilizes mathematical algorithms to create
								self-similar
								patterns and structures.
							</div>
						</div>
						<label for="carousel-3" class="carousel-control prev control-1" id="arrowbutton">‹</label>
						<label for="carousel-2" class="carousel-control next control-1" id="arrowbutton">›</label>
						<label for="carousel-1" class="carousel-control prev control-2" id="arrowbutton">‹</label>
						<label for="carousel-3" class="carousel-control next control-2" id="arrowbutton">›</label>
						<label for="carousel-2" class="carousel-control prev control-3" id="arrowbutton">‹</label>
						<label for="carousel-1" class="carousel-control next control-3" id="arrowbutton">›</label>
						<!-- <ol class="carousel-indicators">
							<li>
								<label for="carousel-1" class="carousel-bullet">•</label>
							</li>
							<li>
								<label for="carousel-2" class="carousel-bullet">•</label>
							</li>
							<li>
								<label for="carousel-3" class="carousel-bullet">•</label>
							</li>
						</ol> -->
					</div>
					<!-- <div class="displaynoneforlargerscreen" id="factral">
						Fractal art is a form of digital art that utilizes mathematical algorithms to create self-similar
						patterns and structures.
					</div>  -->
				</div>

			</div>
		</div>
	</div>
	<div id="text-container">
		<div></div>
	</div>

	<div id="moreInfo1">

		<div class="buttons">
			<div><button id="backwardButton" onclick="changeAttractor(-1)">&larr;</button></div>
			<div id="moreInfo">

			</div>
			<div><button id="forwardBackword" onclick="changeAttractor(1)">&rarr;</button></div>

		</div>
		<div class="moreInfo">

		</div>

	</div>
	<!-- <div id="circle">
        <div id="circle1"></div>
	</div> -->
	<div class="moreInfoalphaBetaphone">
		<div class="moreInfoalphaBetaCirclephone">
			<div class="contentAlpha">An alpha ,beta values influences the behaviour of a system, like a dial
				controlling the balance between predictable patterns and randomness. By changing these alpha,beta value,
				one can study how the system's behavior changes under different settings.</div>
			<button id="skipphone">Skip</button>
			<div></div>
		</div>
	</div>
	<script>

		let ball = false;
		let content = false;

		function displayContent() {
			content = !content;
			if (content) {
				document.getElementById("content").style.display = "block";
				document.getElementsByClassName("valueContainer")[0].style.display = "none";
				document.getElementById("displayContentlargescreen").innerHTML = "X"
			} else {
				document.getElementById("content").style.display = "none";
				document.getElementById("displayContentlargescreen").innerHTML = "i"
			}

			// document.getElementById("displaynoneforlargerscreen").style.display = "block";

		}
		function displayN() {
			document.getElementById("content").style.display = "none"
		}
		function displayvlueContainer() {
			ball = !ball;
			if (ball == true) {
				document.getElementsByClassName("valueContainer")[0].style.display = "block";
				document.getElementById("content").style.display = "none";
				document.getElementById("icon").style.display = "none";
				document.getElementById("x").style.display = "block";



			} else {
				document.getElementsByClassName("valueContainer")[0].style.display = "none";
				document.getElementById("icon").style.display = "block";
				document.getElementById("x").style.display = "none";
			}

		}


		document.getElementById("skip").addEventListener("click", function () {
			document.getElementsByClassName("moreInfoalphaBeta")[0].style.display = "none"
		})
		document.getElementById("skipphone").addEventListener("click", function () {
			document.getElementsByClassName("moreInfoalphaBetaphone")[0].style.display = "none"
			document.getElementsByClassName("valueContainer")[0].style.display = "none"
		})
		let textfield = document.getElementById("text-container")

		let textfieldmoreInfo = document.getElementById("moreInfo")

		const colorPicker = document.querySelector('#colorPicker');
		const colorPreview = document.querySelector('#colorPreview');

		let o; // mathmatical constnts 
		let b;
		let p; //"you down with OBP (yeah you know me!)"
		let q;
		let d;
		let e;
		let r;
		let f;
		let g;
		const num = 200; //number of points
		const tsize = 400; //length of point tails
		const waitTime = 5* 30; //time between each shape (seconds * FPS)
		let a = []; // array of points

		let font;
		let poof;
		let dicon;
		/*to add another shape to the system:
		add another variable case to lorenz/constructor,
		add another function case to lorenz/calculate,
		add 1 to numShapes in newLorenz
		add another if else case to newLorenz with the initail contitions s (randomness) and speed (runtime speed)
		optional : add another text case to draw
		*/


		function preload() {
			// font = loadFont("DMSans-Regular.ttf");
			// poof = loadImage("poof.png");
			// dicon = loadImage("download.png");
		}


		/*****************************************************************************************************************
		 * class that holds the position of each individual point, as well as the trail it leaves behind.
		 * 
		 * calculate function takes the current position, throws it into some funky math, then you get the delta V.
		 * add the deltaV*timestep to the current position and you have the moving point.
		 * 
		 * the position is recorded to an array length "tsize" then a trail using those positions is drawn once per frame.
		 * the trail uses the distance between the current point and the next point to decide how smooth to draw the line.
		 * I wanted to make the trail fade to trasparent near the end, but I couldn't figure out an easy way to do that.
		 ****************************************************************************************************************/


		class lorenz {
			constructor(x, y, z, h, k) {
				this.pos = createVector(x, y, z);
				this.dV = createVector(0, 0, 0);

				this.v1 = createVector(0, 0, 0);
				this.v2 = createVector(0, 0, 0);
				this.prev = [];
				this.prev.push(this.pos.array());
				this.prev.push(this.pos.array());
				this.c = h;
				this.avg = 0;


				this.k = k;

				//initailize variables (variable case)
				switch (k) {
					case 0://lorenz attractor
						o = 10;
						p = 28;
						b = 8 / 3;
						break;
					case 1://chen attractor
						o = 40;
						p = 3;
						b = 28;
						break;
					case 2://chua chaotic attractor
						o = 10.82;
						p = 14.286;
						this.h;
						break;
					case 3://"modified" rossler attractor
						o = 0.1;
						p = 0.1;
						b = 14;
						break;
					case 4://Hadley
						o = 0.2;
						p = 4;
						b=8;
						g=1;
						
						break;
					case 5://THREE-SCROLL UNIFIED CHAOTIC SYSTEM
						o = 32.48;
						p = 45.84;
                        b=1.18;
                        d=0.13;
						e=0.57;
						f=14.7;
						break;
					case 6://HALVORSEN
						o = 2;
						break;
					case 7://RABINOVICH-FABRIKANT
						o = 1;
						b = 8;
						f = 5;
						g = 5;
						break;
					case 8://DADRAS
						o = 3;
						p = 3;
						b = 2;
						q = 2;
						r = 9;
						break;
				}
			}

			/*****************************************************************************
			 * runs the functions that make the patterns
			 * uses the above constants to control the shape
			 * all are accurate to the original functions apart from the rossler attractor
			 * that was modified to prevent numbers approacing infinity
			 ****************************************************************************/
			calculate(t) {
				switch (this.k) { //function cases
					case 0://lorenz
						this.dV.set(this.pos.x + t * o * (this.pos.y - this.pos.x),
							this.pos.y + t * (this.pos.x * (p - this.pos.z) - this.pos.y),
							this.pos.z + t * ((this.pos.x * this.pos.y) - (b * this.pos.z)));
						break;
					case 1://chen
						this.dV.set((this.pos.x + t * o * (this.pos.y - this.pos.x)),
							this.pos.y + t * ((b - o) * this.pos.x - this.pos.x * this.pos.z + b * this.pos.y),
							this.pos.z + t * ((this.pos.x * this.pos.y) - (p * this.pos.z)));
						break;
					case 2://chua
						this.h = -0.11 * sin((PI * this.pos.x) / 2.6);
						this.dV.set((this.pos.x + t * (o * (this.pos.y - this.h))),
							this.pos.y + t * (this.pos.x - this.pos.y + this.pos.z),
							this.pos.z + t * (-p * this.pos.y));
						break;
					case 3://rossler
						this.dV.set(this.pos.x + t * ((-this.pos.y - pow(o * this.pos.z, 2))),
							this.pos.y + t * (this.pos.x + (o * this.pos.y)),
							this.pos.z + t * (p + this.pos.z * (this.pos.x - b)));
						break;
					case 4://Hadley
						this.dV.set(this.pos.x + t * (-(this.pos.y*this.pos.y)-(this.pos.z*this.pos.z)-(o*this.pos.x)+(o*b)),
							this.pos.y + t * ( (this.pos.x* this.pos.y)-(p*this.pos.x*this.pos.z)-(this.pos.y)+g),
							this.pos.z + t * ((p*this.pos.x*this.pos.y)+(this.pos.x*this.pos.z)-this.pos.z));
						break;
					case 5://THREE-SCROLL UNIFIED CHAOTIC SYSTEM
						this.dV.set(this.pos.x + t * ((o*(this.pos.y-this.pos.x)) + (d * this.pos.x * this.pos.z)),
							this.pos.y + t * ( (p* this.pos.x) - (this.pos.x* this.pos.z)+ f*this.pos.y), this.pos.z + t * (b*this.pos.z +(this.pos.x*this.pos.y) -  (e*this.pos.x* this.pos.x)))
						break;
					case 6:  //HALVORSEN
						this.dV.set(this.pos.x + t * (-o * this.pos.x - 4 * this.pos.y - 4 * this.pos.z - (this.pos.y * this.pos.y)),
							this.pos.y + t * (-o * this.pos.y - (4 * this.pos.z) - (4 * this.pos.x) - (this.pos.z * this.pos.z)),
							this.pos.z + t * ((-o * this.pos.z) - (4 * this.pos.x) - (4 * this.pos.y) - (this.pos.x * this.pos.x)));
						break;
					case 7:  //LORENZ83
						this.dV.set(this.pos.x + t *((-o*this.pos.x )-(this.pos.y*this.pos.y) -(this.pos.z*this.pos.z)+ o * f),
							this.pos.y + t * (-this.pos.y + (this.pos.x * this.pos.y ) - (b * this.pos.x * this.pos.z) +g),
							this.pos.z + t * ((-this.pos.z ) +(b * this.pos.x * this.pos.y)+(this.pos.x * this.pos.z)));
						break;
					case 8://DADRAS
						this.dV.set(this.pos.x + t * (this.pos.y - o * this.pos.x + p * this.pos.y * this.pos.z),
							this.pos.y + t * (b * this.pos.y - (this.pos.x * this.pos.z) - this.pos.z),
							this.pos.z + t * ((q * this.pos.x * this.pos.y) - (r * this.pos.z)));
						break;
				}

				this.pos.set(this.dV);
			}


			/****************************
			 * draws the points and tails 
			 ***************************/
			draw() {
				this.prev.push(this.pos.array()); //array of tail vectors
				if (this.prev.length > tsize) {
					this.prev.splice(0, 1);
				}

				//calculates the color of the trail based on the speed of the point
				let G;
				let R = 1;
				this.v1.set(createVector(this.prev[this.prev.length - 1][0], this.prev[this.prev.length - 1][1], this.prev[this.prev.length - 1][2]));
				this.v2.set(createVector(this.prev[this.prev.length - 2][0], this.prev[this.prev.length - 2][1], this.prev[this.prev.length - 2][2]));
				this.mod = p5.Vector.sub(this.v1, this.v2);
				G = this.mod.mag();
				stroke(this.c, 100, G * 50 + 0);


				//draws the tail
				//uses the distance/speed between points to determine how detailed the trail should be
				beginShape();
				vertex(this.prev[this.prev.length - 1][0], this.prev[this.prev.length - 1][1], this.prev[this.prev.length - 1][2]);
				for (let i = this.prev.length - 2; i >= 0; i -= R) {

					this.v1 = createVector(this.prev[i][0], this.prev[i][1], this.prev[i][2]);
					this.v2 = createVector(this.prev[i + 1][0], this.prev[i + 1][1], this.prev[i + 1][2]);
					this.mod = p5.Vector.sub(this.v1, this.v2);
					G = this.mod.mag();
					R = constrain((round(5 / (G + 1))), 1, tsize / 2);

					vertex(this.prev[i][0], this.prev[i][1], this.prev[i][2]);
				}
				vertex(this.prev[0][0], this.prev[0][1], this.prev[0][2]);
				endShape();

				//yes the point at the front is a sphere
				push();
				translate(this.pos.x, this.pos.y, this.pos.z);
				sphere(0.5, 3, 3);
				pop();
			}

		}


		/************************************
		 * adds subtle glow to the background
		 ***********************************/
		function glow() {
			tint(C, 100, 50, constrain(sqrt(time / tsize), 0, 1) * 50);
			// image( -127, -127, 255, 255);
			pop();
		}

		let C;
		/*******************************************
		 * creates and sets up a new attractor shape
		 ******************************************/
		function changeAttractor(direction) {
			console.log(direction)
			aType += direction;
			aType = newLorenz(aType);
		}
		function newLorenz(A) {
			let numShapes = 9;

			A = (((A % numShapes) + numShapes) % numShapes); //iterates next attractor

			let s = 1;//randomness
			let x = 1;//direction specific randomness
			let y = 1;
			let z = 1;

			//remove previous attractor
			while (a.length > 0) {
				a.pop();
			}

			//setup initial variables
			if (A == 0) {
				s = 20;
				sspeed = 0.0005;
			} else if (A == 1) {
				s = 1;
				sspeed = 0.0005;
			} else if (A == 2) {
				s = 0.01;
				sspeed = 0.01;
			} else if (A == 3) {
				s = 1;
				x = 20;
				y = 20;
				z = 0;
				sspeed = 0.002;
			} else if (A == 4) {
				s = 1;
				x = 20;
				y = 20;
				z = 0;
				sspeed = 0.0005;
			} else if (A == 5) {
				s = -3;
				
				x = 3;
				y = 2;
				z = -1;
				sspeed = 0.0001;

			} else if (A == 6) {
				s = 1;
				x = 20;
				y = 20;
				z = 0;
				sspeed = 0.002;
			} else if (A == 7) {
				s = 1;
				x = 10;
				y = 10;
				z = 0;
				sspeed = 0.0005;
			}
			else if (A == 8) {
				s = 1;
				x = 10;
				y = 10;
				z = 0;
				sspeed = 0.0005;
			}

			//make new attractor with randomized colors
			C = map(b, 0, 100, 0, 100);
			for (let i = 0; i < num; i++) {
				a.push(new lorenz(random(x * s, x * -s), random(y * s, y * -s), random(z * s, z * -s), abs(randomGaussian(C, 5)) % 100, A));
			}
			return (A);
		}


		/*******************************************
		 * controls the smooth rotation of the shape
		 ******************************************/
		let mx;
		let mv;
		function orbit() {
			if (mouseIsPressed) {
				mv.add((mouseX - pmouseX) / 1000, (pmouseY - mouseY) / 1000);
			}
			mv.mult(0.9);
			mx.add(mv);
			rotateX(mx.y);
			rotateY(mx.x);
		}

		function setup() {
			mx = createVector(0, 0);
			mv = createVector(0, 0);

			createCanvas(windowWidth, windowHeight, WEBGL);
			strokeWeight(1);
			noFill();

			background(0);
			perspective(PI / 4, width / height, 1, 1000);
			colorMode(HSL, 100);
			blendMode(ADD);
			// textFont(font);

			textAlign(CENTER, CENTER);
			camera(0, 0, 150);
		}

		let time = waitTime + 1;
		let aType = 0;
		let sspeed;

		function draw() {
			if (time > waitTime) {
				time = 0;
				aType = newLorenz(aType);
			}
			const headingsize = Math.min(windowWidth, windowHeight) * 0.008;
			const textsize = Math.min(windowWidth, windowHeight) * 0.0045;
			time++;
			frameRate(30);

			background(0);
			fill(0, 100, 100);
			textSize(textsize);

			push();
			translate(0, 0, -100);
			textSize(headingsize);

			switch (aType) {

				case 0:
					b = parseInt(b)
					textfieldmoreInfo.innerHTML = "Lorenz Attractor"
					$("#slider1").roundSlider("setValue", o);
					$("#slider3").roundSlider("setValue", b);
                    $("#slider2").roundSlider("setValue", p);
					document.getElementById("alpha").innerHTML = o;
					document.getElementById("beta").innerHTML = b;
					document.getElementById("gamma").innerHTML = p;
					// $("#slider3").roundSlider("setValue", 3);
					// text("Lorenz Attractor", 0, -90);
					break;
				case 1:
					b = parseInt(b)
					// text("Chen Attractor", 0, -90);
					textfieldmoreInfo.innerHTML = "Chen Attractor"
					$("#slider1").roundSlider("setValue", o);
					$("#slider3").roundSlider("setValue", b);
					$("#slider2").roundSlider("setValue", p);
					document.getElementById("alpha").innerHTML = o;
					document.getElementById("beta").innerHTML = p;
					document.getElementById("gamma").innerHTML = b;
					break;
				case 2:
					b = parseInt(b)
					// text("Modified Chua Chaotic Attractor", 0, -90);
					textfieldmoreInfo.innerHTML = "Modified Chua Chaotic Attractor"
					$("#slider1").roundSlider("setValue", o);
					$("#slider3").roundSlider("setValue", b);
					$("#slider2").roundSlider("setValue", p);
					document.getElementById("alpha").innerHTML = o;
					document.getElementById("beta").innerHTML = p;
					document.getElementById("gamma").innerHTML = b;
					break;
				case 3:
					b = parseInt(b)
					// text("Modified Rossler Attractor", 0, -90);
					textfieldmoreInfo.innerHTML = "Modified Rossler Attractor"
					$("#slider1").roundSlider("setValue", o);
					$("#slider3").roundSlider("setValue", b);
					$("#slider2").roundSlider("setValue", p);
					document.getElementById("alpha").innerHTML = o;
					document.getElementById("beta").innerHTML = p;
					document.getElementById("gamma").innerHTML = b;
					break;
				case 4:
					b = parseInt(b)
					// text("Modified Rossler Attractor", 0, -90);
					textfieldmoreInfo.innerHTML = "Hadley"
					$("#slider1").roundSlider("setValue", o);
					$("#slider3").roundSlider("setValue", b);
					$("#slider2").roundSlider("setValue", p);
					document.getElementById("alpha").innerHTML = o;
					document.getElementById("beta").innerHTML = p;
					document.getElementById("gamma").innerHTML = b;
					break;
				case 5:
					b = parseInt(b)
					// text("Modified Rossler Attractor", 0, -90);
					textfieldmoreInfo.innerHTML = "THREE-SCROLL UNIFIED CHAOTIC SYSTEM"
					$("#slider1").roundSlider("setValue", o);
					$("#slider3").roundSlider("setValue", b);
					$("#slider2").roundSlider("setValue", p);
					document.getElementById("alpha").innerHTML = o;
					document.getElementById("beta").innerHTML = p;
					document.getElementById("gamma").innerHTML = b;
					break;
				case 6:
					b = parseInt(b)
					// text("Modified Rossler Attractor", 0, -90);
					textfieldmoreInfo.innerHTML = "HALVORSEN"
					$("#slider1").roundSlider("setValue", o);
					$("#slider3").roundSlider("setValue", b);
					$("#slider2").roundSlider("setValue", p);
					document.getElementById("alpha").innerHTML = o;
					document.getElementById("beta").innerHTML = p;
					document.getElementById("gamma").innerHTML = b;
					break;
				case 7:
					b = parseInt(b)
					// text("Modified Rossler Attractor", 0, -90);
					textfieldmoreInfo.innerHTML = "RABINOVICH-FABRIKANT"
					$("#slider1").roundSlider("setValue", o);
					$("#slider3").roundSlider("setValue", b);
					$("#slider2").roundSlider("setValue", p);
					document.getElementById("alpha").innerHTML = o;
					document.getElementById("beta").innerHTML = p;
					document.getElementById("gamma").innerHTML = b;
					break;
				case 8:
					b = parseInt(b)
					// text("Modified Rossler Attractor", 0, -90);
					textfieldmoreInfo.innerHTML = "DADRAS"
					$("#slider1").roundSlider("setValue", o);
					$("#slider3").roundSlider("setValue", b);
					$("#slider2").roundSlider("setValue", p);
					document.getElementById("alpha").innerHTML = o;
					document.getElementById("beta").innerHTML = p;
					document.getElementById("gamma").innerHTML = b;
					break;
			}
			textSize(textsize);
			let sentence = "Note: This is a 3D generative model.  Drag mouse to move around. Press space bar on keyboard to generate new attractor"
			// text(sentence.toLowerCase(), 0, 90);
			textfield.innerHTML = "Attractor"
			glow();
			orbit();
			noFill();

			push();
			translate(0, 0, -20);
			for (let x = 0; x < num; x++) {
				for (let i = 0; i < 10; i++) {

					a[x].calculate(sspeed);

				}
				//a[x].glow();
				a[x].draw();

			}
			pop();
		}

		const hues = [];
		function keyPressed() {
			time = waitTime;
		}

		let sliderValue = 50; // initial slider value

		function updateColor(hue) {
			console.log(hue)
			const saturation = 100;
			const lightness = 50;

			// update color of the attractor shape
			for (let i = 0; i < a.length; i++) {
				a[i].c = color(hues[i % hues.length], saturation, lightness); // set the color of the attractor based on the stored hue value
			}

		}



		$("#slider1").roundSlider({
			radius: 74.82,
			width: 5,
			handleSize: "+10",
			handleShape: "dot",
			sliderType: "min-range",
			value: 10,
			tooltipFormat: "tooltipVal1",
			borderColor: "transparent",
			border: null,
			min: 0,
			max: 100,
			step: 1,
			rangeColor: "#FF0000",
			drag: function (event) {
				// handle slider value changes here
				console.log("Slider value changed to:", event.value);
				o = event.value;
			}
		});
		function tooltipVal1(args) {
			if (o == undefined) {
				var val = "alpha" + " " + 10
			}
			if (o != undefined) {
				var val = "alpha " + " " + o
			}


			return val;
		}

		$("#slider3").roundSlider({
			radius: 74.82,
			width: 5,
			handleSize: "+10",
			handleShape: "dot",
			sliderType: "min-range",
			value: 3,
			tooltipFormat: "tooltipVal10",
			drag: function (event) {
				// handle slider value changes here
				console.log("Slider value changed to:", event.value);
				b = event.value;
			}
		});
		function tooltipVal10(args) {
			if (b == undefined) {
				var val = "beta" + " " + 3
			}
			if (b != undefined) {
				var val = "beta" + " " + parseInt(b)
			}


			return val;
		}


		$("#slider2").roundSlider({
			radius: 74.82,
			width: 5,
			handleSize: "+10",
			handleShape: "dot",
			sliderType: "min-range",
			value: 3,
			tooltipFormat: "tooltipVal20",
			drag: function (event) {
				// handle slider value changes here
				console.log("Slider value changed to:", event.value);
				p = event.value;
			}
		});
		function tooltipVal20(args) {
			if (p == undefined) {
				var val = "gamma" + " " + 3
			}
			if (p != undefined) {
				var val = "gamma" + " " + parseInt(p)
			}


			return val;
		}
		$("#uniqueslider").roundSlider({
			radius: 74.82,
			width: 5,
			handleSize: "+10",
			handleShape: "dot",
			sliderType: "min-range",
			value: 3,
			tooltipFormat: "tooltipVal2",
			drag: function (event) {
				// handle slider value changes here
				console.log("Slider value changed to:", event.value);
				b = event.value;
			}
		});
		function tooltipVal2(args) {
			if (b == undefined) {
				var val = "beta" + " " + 3
			}
			if (b != undefined) {
				var val = "beta" + " " + parseInt(b)
			}


			return val;
		}

		function tooltipVal3(args) {
			if (p == undefined) {
				var val = "gamma" + " " + 3
			}
			if (p != undefined) {
				var val = "gamma" + " " + parseInt(p)
			}


			return val;
		}

		colorPicker.addEventListener('input', function () {
			const hue = this.value;
			const color = `hsl(${hue}, 100%, 50%)`;
			colorPreview.style.backgroundColor = color;
			hues[0] = hue; // store the hue value in an array
			updateColor(hues);

		});

		colorPicker1.addEventListener('input', function () {
			const hue = this.value;
			const color = `hsl(${hue}, 100%, 50%)`;
			colorPreview1.style.backgroundColor = color;
			hues[0] = hue; // store the hue value in an array
			updateColor(hues);

		});
		let zoom = 1.0; // initial zoom level

		function mouseWheel(event) {
			// increase or decrease zoom level based on mouse wheel direction
			zoom += event.delta * 0.001;

			// limit zoom level to a reasonable range
			zoom = constrain(zoom, 0.1, 10.0);

			// adjust camera position based on zoom level
			camera(0, 0, 150 * zoom);
		}
		// let lastDist = null;
		// let currDist = null;
		// let scaleFactor = 1;

		// function handleTouchStart(evt) {
		// 	if (evt.touches.length > 1) {
		// 		// calculate the distance between the two touch points
		// 		lastDist = getTouchDistance(evt.touches);
		// 	}
		// }

		// function handleTouchMove(evt) {
		// 	if (evt.touches.length > 1) {
		// 		// calculate the distance between the two touch points
		// 		currDist = getTouchDistance(evt.touches);

		// 		if (lastDist !== null && currDist !== null) {
		// 			// calculate the scaling factor
		// 			scaleFactor = currDist / lastDist;

		// 			// apply the scaling factor
		// 			scale(scaleFactor);

		// 			// reset the distances
		// 			lastDist = currDist;
		// 			currDist = null;
		// 		}
		// 	}
		// }



		// function handleTouchEnd(evt) {
		// 	// reset the distances and scaling factor
		// 	lastDist = null;
		// 	currDist = null;
		// 	scaleFactor = 1;
		// }

		// function getTouchDistance(touches) {
		// 	const x1 = touches[0].pageX;
		// 	const y1 = touches[0].pageY;
		// 	const x2 = touches[1].pageX;
		// 	const y2 = touches[1].pageY;

		// 	return dist(x1, y1, x2, y2);
		// }

		// // attach the touch event listeners
		// document.addEventListener('touchstart', handleTouchStart);
		// document.addEventListener('touchmove', handleTouchMove);
		// document.addEventListener('touchend', handleTouchEnd);
		//scrollable ball
		var dragItem = document.querySelector("#item");
		var container = document.querySelector("#container");

		var active = false;
		var currentX;
		var currentY;
		var initialX;
		var initialY;
		var xOffset = 0;
		var yOffset = 0;

		container.addEventListener("touchstart", dragStart, false);
		container.addEventListener("touchend", dragEnd, false);
		container.addEventListener("touchmove", drag, false);

		container.addEventListener("mousedown", dragStart, false);
		container.addEventListener("mouseup", dragEnd, false);
		container.addEventListener("mousemove", drag, false);

		function dragStart(e) {
			if (e.type === "touchstart") {
				initialX = e.touches[0].clientX - xOffset;
				initialY = e.touches[0].clientY - yOffset;
			} else {
				initialX = e.clientX - xOffset;
				initialY = e.clientY - yOffset;
			}

			if (e.target === dragItem) {
				active = true;
			}
		}

		function dragEnd(e) {
			initialX = currentX;
			initialY = currentY;

			active = false;
		}

		function drag(e) {
			if (active) {

				e.preventDefault();

				if (e.type === "touchmove") {
					currentX = e.touches[0].clientX - initialX;
					currentY = e.touches[0].clientY - initialY;
				} else {
					currentX = e.clientX - initialX;
					currentY = e.clientY - initialY;
				}

				xOffset = currentX;
				yOffset = currentY;

				setTranslate(currentX, currentY, dragItem);
			}
		}

		function setTranslate(xPos, yPos, el) {
			el.style.transform = "translate3d(" + xPos + "px, " + yPos + "px, 0)";
		}
		$("#uniqueslider1").roundSlider({
			radius: 74.82,
			width: 5,
			handleSize: "+10",
			handleShape: "dot",
			sliderType: "min-range",
			value: 3,
			tooltipFormat: "tooltipVal1",
			// drag: function (event) {
			// 	// handle slider value changes here
			// 	console.log("Slider value changed to:", event.value);
			// 	o= event.value;
			// }
		});

		let alpha1 = document.getElementById("alphaa")
		let beta1 = document.getElementById("betaa")
		let gamma1 = document.getElementById("gammaa")

		alpha1.addEventListener('click', updatealpha);
		beta1.addEventListener('click', updatebeta);
		gamma1.addEventListener('click', updategamma);

		function updatealpha() {

			document.getElementById("uniqueslider").style.display = "none"
			document.getElementById("uniqueslider1").style.display = "block"
			document.getElementById("uniqueslider2").style.display = "none"
			document.getElementById("uniqueslider3").style.display = "none"
			this.classList.add('clicked');
			beta1.classList.remove("clicked");
			gamma1.classList.remove("clicked")
			$("#uniqueslider1").roundSlider({
				radius: 74.82,
				width: 5,
				handleSize: "+10",
				handleShape: "dot",
				sliderType: "min-range",
				value: 3,
				tooltipFormat: "tooltipVal1",
				drag: function (event) {
					// handle slider value changes here
					console.log("Slider value changed to:", event.value);
					o = event.value;
				}
			});
			document.getElementsByClassName("constantValues")[0].classList.add("filling-button")
		}


		function updatebeta() {

			document.getElementById("uniqueslider").style.display = "none"
			document.getElementById("uniqueslider1").style.display = "none"
			document.getElementById("uniqueslider2").style.display = "block"
			document.getElementById("uniqueslider3").style.display = "none"
			this.classList.add('clicked');

			alpha1.classList.remove("clicked");
			gamma1.classList.remove("clicked")

			$("#uniqueslider2").roundSlider({
				radius: 74.82,
				width: 5,
				handleSize: "+10",
				handleShape: "dot",
				sliderType: "min-range",
				value: 3,
				tooltipFormat: "tooltipVal2",
				drag: function (event) {
					// handle slider value changes here
					console.log("Slider value changed to:", event.value);
					b = event.value;
				}

			});

		}



		function updategamma() {

			document.getElementById("uniqueslider").style.display = "none"
			document.getElementById("uniqueslider1").style.display = "none"
			document.getElementById("uniqueslider2").style.display = "none"
			document.getElementById("uniqueslider3").style.display = "block"

			this.classList.add('clicked');
			alpha1.classList.remove("clicked");
			beta1.classList.remove("clicked")
			$("#uniqueslider3").roundSlider({
				radius: 74.82,
				width: 5,
				handleSize: "+10",
				handleShape: "dot",
				sliderType: "min-range",
				value: 3,
				tooltipFormat: "tooltipVal3",
				drag: function (event) {
					// handle slider value changes here
					console.log("Slider value changed to:", event.value);
					p = event.value;
				}

			});

		}
		// Master DOManipulator v2 ------------------------------------------------------------
		const items = document.querySelectorAll('.item'),
			controls = document.querySelectorAll('.control'),
			headerItems = document.querySelectorAll('.item-header'),
			descriptionItems = document.querySelectorAll('.item-description'),
			activeDelay = .76,
			interval = 5000;

		let current = 0;

		const slider = {
			init: () => {
				controls.forEach(control => control.addEventListener('click', (e) => { slider.clickedControl(e) }));
				controls[current].classList.add('active');
				items[current].classList.add('active');
			},
			nextSlide: () => { // Increment current slide and add active class
				slider.reset();
				if (current === items.length - 1) current = -1; // Check if current slide is last in array
				current++;
				controls[current].classList.add('active');
				items[current].classList.add('active');
				slider.transitionDelay(headerItems);
				slider.transitionDelay(descriptionItems);
			},
			clickedControl: (e) => { // Add active class to clicked control and corresponding slide
				slider.reset();
				clearInterval(intervalF);

				const control = e.target,
					dataIndex = Number(control.dataset.index);

				control.classList.add('active');
				items.forEach((item, index) => {
					if (index === dataIndex) { // Add active class to corresponding slide
						item.classList.add('active');
					}
				})
				current = dataIndex; // Update current slide
				slider.transitionDelay(headerItems);
				slider.transitionDelay(descriptionItems);
				intervalF = setInterval(slider.nextSlide, interval); // Fire that bad boi back up
			},
			reset: () => { // Remove active classes
				items.forEach(item => item.classList.remove('active'));
				controls.forEach(control => control.classList.remove('active'));
			},
			transitionDelay: (items) => { // Set incrementing css transition-delay for .item-header & .item-description, .vertical-part, b elements
				let seconds;

				items.forEach(item => {
					const children = item.childNodes; // .vertical-part(s)
					let count = 1,
						delay;

					item.classList.value === 'item-header' ? seconds = .015 : seconds = .007;

					children.forEach(child => { // iterate through .vertical-part(s) and style b element
						if (child.classList) {
							item.parentNode.classList.contains('active') ? delay = count * seconds + activeDelay : delay = count * seconds;
							child.firstElementChild.style.transitionDelay = `${delay}s`; // b element
							count++;
						}
					})
				})
			},
		}

		let intervalF = setInterval(slider.nextSlide, interval);
		slider.init();




	</script>
</body>

</html>



<!-- <div class="displaynoneforlargerscreen">

	<div class="css-slider">

		<input id="slide-1" type="radio" name="slides" checked>
		<section class="slide slide-one">

			<h2 id="headings">Astrophysics</h2>

			<nav>
				<label for="slide-3" class="prev">&#10094;</label>
				<label for="slide-2" class="next">&#10095;</label>

			</nav>
			<div class="imageContainer">
				<div class="block imgblock"><img src="nasa-rTZW4f02zY8-unsplash.jpg" alt="" srcset="">
				</div>
				<div class="block">Galaxies and Cosmic structures show factral patterns,used to model
					the universe's large scale structure</div>
			</div>

		</section>
		<input id="slide-2" type="radio" name="slides">
		<section class="slide slide-two">
			<h2 id="headings">Ocean Current</h2>
			<nav>
				<label for="slide-1" class="prev">&#10094;</label>
				<label for="slide-3" class="next">&#10095;</label>

			</nav>
			<div class="imageContainer">
				<div class="block imgblock"><img src="pexels-pixabay-462162.jpg" alt="" srcset=""></div>
				<div class="block">The Ocean current analysis predicts the complex oceanic
					movement,imapacting climatic and marine life</div>
			</div>

		</section>
		<input id="slide-3" type="radio" name="slides">
		<section class="slide slide-three">
			<h2 id="headings">Medical</h2>
			<nav>
				<label for="slide-2" class="prev">&#10094;</label>
				<label for="slide-1" class="next">&#10095;</label>

			</nav>
			<div class="imageContainer">
				<div class="block imgblock"><img src="pexels-vidal-balielo-jr-1250655.jpg" alt=""
						srcset=""></div>
				<div class="block">Factrol analysis detects the patterns in biological structures to
					diagonise diseases and monitor treatment</div>
			</div>


		</section>
		<header>
			<label for="slide-1" id="slide-1"></label>
			<label for="slide-2" id="slide-2"></label>
			<label for="slide-3" id="slide-3"></label>
		</header>
	</div>
</div>
<div class="displaynoneforlargerscreen">
	Fractal art is a form of digital art that utilizes mathematical algorithms to create self-similar
	patterns and structures.
</div> -->
